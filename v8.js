`
    js 属性对象的访问速度：
    js访问对象有两种方式：
        Dictionary(Slow) Mode：字典模式也称为哈希表模式，V8 使用哈希表来存储对象的属性。
        Stable(Fast) Mode：使用类似数组（C Struct）结构来存储对象的属性并使用 Offset 进行访问。

    新创建的小对象为快速模式（Fast Mode），当执行如下操作时会退化成为字典模式（Dictionary Mode）：
        动态添加过多的属性
        删除属性（delete）
        删除非最后添加的属性
    也就是说当对象被当作哈希表使用时（如存储大量数据），他就会退化到字典模式。

    *当对象被设置成为一个函数（或对象）的原型时也会从字典模式优化成为快速（Fast） 模式。
    **V8 中具有相同构建结构的 JSObject 对象，具有相同的内存（空间）布局

    沿着属性添加的反方向删除属性时，对象不会退化为字典模式，因为back pointer 引用链
    <Map> 实例都有一个 backpointer 字段引用其前一个（Transition） <Map>

    如果以属性添加的反方向删除属性时，可以方便的通过对象 <Map> 形成的 backpointer 引用链回滚到上一次的状态而无需退化到字典模式。
    如果删除的属性并非最后添加到对象内时，backpointer 引用链也无能为力，这时 V8 就会以字典模式来表达对象了。

    // 由FastProperties 变成了  DictionaryProperties等等，因为back pointer（反向指针指向了undefined）

     V8 引擎为了优化性能做了preparser
     惰性 parse：
        在执行函数时，只会将最外层执行的函数完全编译并生成 AST，而对内部模块只进行 preparser。
    为了允许惰性编译函数，上下文指针指向了 ScopeInfo 的对象（从代码中可以看到，ScopeInfo 包含上下文信息，比如当前上下文是否有函数名，是否在一个函数内等等），当编译内部函数时，可以利用 ScopeInfo 继续编译子函数。

    v8如何编译调试
    v8源码可以在GitHub上面看到，本地编译比较大，需要用到xcode，我本地用的是jsvu，这个可以将js编译成v8

    v8的垃圾回收
    三色标记算法，函数执行之后，就清除标记进行回收
    v8对于垃圾回收分为新生代（new generation）和老生代（old generation）
    新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

    Incremental Marking（增量标记）
    由于全停顿会造成了浏览器一段时间无响应，所以V8使用了一种增量标记的方式，将完整的标记拆分成很多部分，每做完一部分就停下来，让JS的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的1/6左右

    惰性清理
    由于标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。我们可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。垃圾回收器可以根据需要逐一清理死对象所占用的内存页

    其他
    V8后续还引入了增量式整理（incremental compaction），以及并行标记和并行清理，通过并行利用多核CPU来提升垃圾回收的性能
    总结
    V8的垃圾回收机制分为新生代和老生代。

    新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。

    老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。



    什么是内联缓存？
    要回答这个问题，我们需要知道 IC 的工作原理。其实 IC 的原理很简单，直观地理解，就是在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。




`
